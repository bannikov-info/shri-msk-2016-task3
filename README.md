#Задание

Склонируйте код из репозитория: `git clone https://github.com/shri-msk-2016/task3.git`

Выполните `npm install`, а затем `npm start` и откройте приложение в браузере (<http://localhost:3000>).

Приложение позволяет добавлять и редактировать данные студентов ШРИ (ФИО, ссылку на фотографию и краткую информацию). Для работы в офлайне оно использует ServiceWorker, позволяя при этом, как минимум, просматривать данные студентов.

Однако при реализации были допущены несколько ошибок:

* Без подключения к серверу приложение не работает.
* Не всегда обновляется список студентов после добавления нового.

Найдите и исправьте ошибки. В качестве дополнительного задания вы можете реализовать добавление студентов в офлайне с последующей синхронизацией. При выполнении обратите внимание на способы определения режима «онлайн/офлайн».

Результат пришлите в виде ссылки на https://github.com

##Что мы проверяем этим заданием?

Мы хотим проверить вашу способность разобраться в незнакомом коде и/или API. Также с помощью этого задания мы оценим ваш навык отладки. Поэтому прокомментируйте, пожалуйста, в коде или текстовом файле README ход ваших мыслей — какие ошибки и как вы нашли, почему они возникли и какие способы исправления существуют. Мы не ограничиваем вас в использовании сторонних инструментов и библиотек, однако при их использовании также ожидаем комментариев, в которых вы расскажете, зачем и почему было использовано то или иное средство.

##Решение

Клиентская часть приложения очень проста - две папки и четыре статичаских файла.  

Чтобы сервис-воркер заработал нужно:

1. Отдавать файл страницы по HTTPS.
2. Правильно зарегистрировать воркера. 
3. Обеспечить соответствие области видимости воркера местоположению файлов, которые он должен обрабатывать. 
4. Обеспечить наполнения кеша статическими ресурсами. 

Так как для работы выбрана платформа Сoloud9, то с раздачей приложения по HTTPS проблем нет - она там включена по умолчанию.

При первом же взгляде на исходник index.html бросается в глаза то, что воркер регистрируется по пути /js/worker.js. Такая регистрация позволяет браузеру получить файл воркера, провести регистрацию, вполне возможно он пройдет стадии инсталяции и активации, но этот воркер не будет запущен для главной страницы приложения (даже в offline), потому как его область видимости сужена до папки /js/. Чтобы решить проблему, нужно просто напросто переместить файл воркера в ту же папку, где находится index.html, ну и конечно же поправить путь регистрации. 

Не помешало бы сразу хотя бы по диагонали глянуть на код файла worker.js. Сразу же редактор подсветил синтаксическую ошибку в 36-й строке, так же сразу обращаю внимание на то, что некоректно указаны пути до кешируемых файлов таблицы стилей и JavaScript-файла приложения. Вносим изменения и пробуем запустить приложение.

Действительно, приложение запустилось, воркер установился, ресурсы закешировались, отображается форма, список студентов, только вот его фото почему то не стало. Ага, после установки воркера, страницу нужно перезагрузить, чтобы он получил контроль. Жму F5... хм.. результат тот же - аватара нет. Смотрим в диспетчер ресурсов - воркер есть и запущен, ещё ошибками в консоли ругается, как раз в тему загрузки аватарки. Стоило бы взглянуть на то, как воркер динамически загружает ресурсы. Самое интересное в том, что url картинки соответствует вот такому блоку загрузки:

```javascript
return event.respondWith(
        getFromCache(event.request).catch(fetchAndPutToCache)
    );
```
    
Это та самая 36-я строчка кода, видимо не просто так именно в ней сделали синтаксическую ошибку, как оказалось еще и логическую. Дело в том что метод `fetchAndPutToCache()` ожидает в качестве аргумента объект запроса. В тоже время, если сработает блок `.catch()` (а это обязательно произойдет для незакешированного ресурса такого как картинка) то метод `fetchAndPutToCache()` будет вызван без объекта-запроса. Проблему можно решить с помощью карринга:

```javascript
return event.respondWith(
        getFromCache(event.request).catch(fetchAndPutToCache.bind(this, event.request))
    );
```
    
Сохраняю изменения, удаляю для чистоты эксперимента из браузера воркера и его кэш. Два раза перезагружаю страницу и... Блин, где список студентов? Смотрю в консоль - и правда, приложение ругается, что приложение не смогло получить файл /api/v1/students.json. Странно, жму F5, хм... все на месте... А что было? 

Итак, проблема возникла при первой загрузке страницы после установки воркера. В этот момент в кэше только 3 файла: index.html, index.js, index.css. Ага, список студентов не в кэше. А так как запрос этого файла сперва проходит через воркер, то нужно посмотреть, как он это делает:

```javascript
    if (/^\/api\/v1/.test(requestURL.pathname)) {
        return event.respondWith(
            Promise.race([
                fetchAndPutToCache(event.request),
                getFromCache(event.request)
            ])
        );
    }
```

После анализа работы кода методов `fetchAndPutToCache()` и `getFromCache()`, становится понятно, что в случае, если кеширование используется только для поддержки offline-режима, то использование метода `getFromCache()` излишне, как и вообще конструкции `Promise.race([])` (более того, эту конструкцию нельзя использовать даже если кеширование применяется для уменьшения трафика). Исправляем, удаляем воркера/кэш, два раза F5... И правда, все поправилось. Как бонус, после анализа работы кода в файле index.js клиентской части, а так же серверных сценариев обработки POST и GET запросов, становится понятно, что именно эта проблема была причиной так же того, что не всегда обновлялся список студентов после добавления нового.